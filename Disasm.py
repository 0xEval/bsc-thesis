#!/usr/bin/python3
# -----------------------------------------------------------------------------
# Disasm.py
# Extracts and prints asm instructions available in a given object file. Uses
# Capstone dissassembly framework.
# NB: Compile the object file in x86 not x86_64 (might be supported later).
#
# Author: Eval (@cyberjucou)
# -----------------------------------------------------------------------------

import subprocess
import argparse
import re
import pprint
from capstone import Cs, CsError, CS_ARCH_X86, CS_MODE_32
from capstone.x86 import X86_OP_REG, X86_OP_IMM, X86_OP_FP, X86_OP_MEM
from xprint import to_hex, to_x, to_x_32


def extract_opcode(dump):
    """
    Extracts and returns the opcode string (in hex) of a given object dump

    Args:
        dump: Output of objdump in NASM syntax.
    Returns:
        Hex string made of the opcodes found in dump.
    """
    opcode = ""
    for line in dump.splitlines():
        match = re.search(r' ([\da-f]+):\s+((?:[0-9a-f]{2} )+)', line)
        print(match)
        tmp = match.group(2).strip().split(' ')
        print(tmp)
        for op in tmp:
            opcode += op
        opcode += ' '
    return opcode


def print_insn_detail(mode, insn):
    """
    Formatted print of all the details contaited in a given instruction.
    The format can vary depending on the compilation mode (32, 64bits...)

    Args:
        mode: Target architecture mode.
        insn: Capstone object representing one instruction line.
    """
    def print_string_hex(comment, str):
        """ Formatted print of instruction detail w/ code in Hex format """
        print(comment, end=' ')
        for c in str:
            print("0x%02x " % c, end='')
        print()

    # print address, mnemonic and operands
    print("0x%x:\t%s\t%s" % (insn.address, insn.mnemonic, insn.op_str))

    # "data" instruction generated by SKIPDATA option has no detail
    if insn.id == 0:
        return

    # print instruction prefix
    print_string_hex("\tPrefix:", insn.prefix)

    # print instruction's opcode
    print_string_hex("\tOpcode:", insn.opcode)

    # print operand's REX prefix
    # (non-zero value is relavant for x86_64 instructions)
    print("\trex: 0x%x" % (insn.rex))

    # print operand's address size
    print("\taddr_size: %u" % (insn.addr_size))

    # print modRM byte
    print("\tmodrm: 0x%x" % (insn.modrm))

    # print displacement value
    print("\tdisp: 0x%s" % to_x_32(insn.disp))

    # SIB is not available in 16-bit mode
    # if (mode & CS_MODE_16 == 0):
    #    # print SIB byte
    #    print("\tsib: 0x%x" % (insn.sib))
    #    if (insn.sib):
    #        if insn.sib_base != 0:
    #            print("\t\tsib_base: %s" % (insn.reg_name(insn.sib_base)))
    #        if insn.sib_index != 0:
    #            print("\t\tsib_index: %s" % (insn.reg_name(insn.sib_index)))
    #        if insn.sib_scale != 0:
    #            print("\t\tsib_scale: %d" % (insn.sib_scale))

    count = insn.op_count(X86_OP_IMM)
    if count > 0:
        print("\timm_count: %u" % count)
        for i in range(count):
            op = insn.op_find(X86_OP_IMM, i + 1)
            print("\t\timms[%u]: 0x%s" % (i + 1, to_x(op.imm)))

    if len(insn.operands) > 0:
        print("\top_count: %u" % len(insn.operands))
        c = -1
        for i in insn.operands:
            c += 1
            if i.type == X86_OP_REG:
                print("\t\toperands[%u].type: REG = %s"
                      % (c, insn.reg_name(i.reg)))
            if i.type == X86_OP_IMM:
                print("\t\toperands[%u].type: IMM = 0x%s" % (c, to_x(i.imm)))
            if i.type == X86_OP_FP:
                print("\t\toperands[%u].type: FP = %f" % (c, i.fp))
            if i.type == X86_OP_MEM:
                print("\t\toperands[%u].type: MEM" % c)
                if i.mem.segment != 0:
                    print("\t\t\toperands[%u].mem.segment: REG = %s" %
                          (c, insn.reg_name(i.mem.segment)))
                if i.mem.base != 0:
                    print("\t\t\toperands[%u].mem.base: REG = %s"
                          % (c, insn.reg_name(i.mem.base)))
                if i.mem.index != 0:
                    print("\t\t\toperands[%u].mem.index: REG = %s" %
                          (c, insn.reg_name(i.mem.index)))
                if i.mem.scale != 1:
                    print("\t\t\toperands[%u].mem.scale: %u" %
                          (c, i.mem.scale))
                if i.mem.disp != 0:
                    print("\t\t\toperands[%u].mem.disp: 0x%s" %
                          (c, to_x(i.mem.disp)))

            print("\t\toperands[%u].size: %u" % (c, i.size))


def insn_type(op1, op2):
    insn_type = "not supported"
    if (op1.type == X86_OP_REG and op2.type == X86_OP_MEM)\
            or (op1.type == X86_OP_IMM and op2.type == X86_OP_MEM):
        insn_type = "load"
    elif (op1.type == X86_OP_MEM and op2.type == X86_OP_REG) \
            or (op1.type == X86_OP_MEM and op2.type == X86_OP_IMM):
        insn_type = "store"
    return insn_type


def insn_detail(insn):
    op1 = insn.operands[0]  # Destination reg
    op2 = insn.operands[1]  # Source reg
    instruction = (insn_type(op1, op2),)
    for i in (op1, op2):
        if i.type == X86_OP_REG:
            instruction += (insn.reg_name(i.reg),)
        if i.type == X86_OP_IMM:
            instruction += (i.imm,)
        if i.type == X86_OP_MEM:
            if i.mem.segment != 0:
                instruction += (insn.reg_name(i.mem.segment),)
            if i.mem.base != 0:
                instruction += (insn.reg_name(i.mem.base),)
            if i.mem.index != 0:
                instruction += (insn.reg_name(i.mem.index),)
            if i.mem.disp != 0:
                instruction += (i.mem.disp,)
    return instruction


def test_class():
    insn_list = []
    for (arch, mode, code, comment, syntax) in all_tests:
        print("*" * 16)
        print("Platform: %s" % comment)
        print("Code: %s" % to_hex(code))
        print("Disasm:")

        try:
            md = Cs(arch, mode)
            md.detail = True

            if syntax != 0:
                md.syntax = syntax

            for insn in md.disasm(code, 0x1000):
                print(insn)
                if (insn.mnemonic == "mov"):
                    insn_list.append(insn_detail(insn))
                print_insn_detail(mode, insn)
                print("")
            pprint.pprint(insn_list)
        except CsError as e:
            print("ERROR: %s" % e)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='')
    parser.add_argument("target", help="path to target binary")
    args = parser.parse_args()
    target = args.target

    header_size = 7
    objdump = subprocess.check_output(
        ["objdump", "-d", "-M", "intel", target]
    )
    objdump = objdump.decode('utf-8')
    objdump = objdump.split('\n', header_size)[-1]

    print("*" * 16)
    print("Dumping: " + target + "\n%s" % objdump)
    opcode = extract_opcode(objdump)
    print("\nOpcode: %s" % opcode)

    X86_CODE32 = bytes.fromhex(opcode)

    all_tests = (
            (CS_ARCH_X86, CS_MODE_32, X86_CODE32, "X86 32 (Intel syntax)", 0),
    )

    test_class()
