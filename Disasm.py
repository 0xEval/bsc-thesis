#!/usr/bin/python3
# -----------------------------------------------------------------------------
# Disasm.py
# Extracts and prints asm instructions available in a given object file. Uses
# Capstone dissassembly framework.
# NB: Compile the object file in x86 not x86_64 (might be supported later).
#
# Author: Eval
# GitHub: https://github.com/jcouvy
# -----------------------------------------------------------------------------

from Structures import Instruction
from Mnemonics import OPCODES

import subprocess
import argparse
import re
from capstone import Cs, CsError, CS_ARCH_X86, CS_MODE_32
from capstone.x86 import X86_OP_REG, X86_OP_IMM, X86_OP_FP, X86_OP_MEM
from xprint import to_hex, to_x, to_x_32


class Disasm:
    """
    The disassembler module will extract the available instructions from a
    given object file. When initiated, the disasm is paired with a single
    target, providing Capstone's functionalities for it.  It will only search
    for `mov` instructions as this is the focus of our tool.
    """
    def __init__(self, all_tests):
        for (arch, mode, code, comment, syntax) in all_tests:
            self.md = Cs(arch, mode)
            self.md.detail = True
            self.code = code
            self.mode = mode
            if not syntax:
                self.md.syntax = syntax

    def extract_insn(self):
        """ Returns a list of all `mov` instructions found in a object dump """
        insn_list = []
        for insn in self.md.disasm(self.code, 0x1000):
            if (insn.mnemonic == "mov"):
                insn_list.append(insn_detail(insn))
        return insn_list


def extract_opcode(dump):
    """
    Extracts and returns the opcode string (in hex) of a given object dump

    Args:
        dump: Output of objdump in NASM syntax.
    Returns:
        Hex string made of the opcodes found in dump.
    """
    opcode = ""
    for line in dump.splitlines():
        match = re.search(r' ([\da-f]+):\s+((?:[0-9a-f]{2} )+)', line)
        tmp = match.group(2).strip().split(' ')
        for op in tmp:
            opcode += op
        opcode += ' '
    return opcode


def print_insn_detail(mode, insn):
    """
    Formatted print of all the details contaited in a given instruction.
    The format can vary depending on the compilation mode (32, 64bits...)

    Args:
        mode: Target architecture mode.
        insn: Capstone object representing one instruction line.
    """
    def print_string_hex(comment, str):
        """ Formatted print of instruction detail w/ code in Hex format """
        print(comment, end=' ')
        for c in str:
            print("0x%02x " % c, end='')
        print()

    # print address, mnemonic and operands
    print("0x%x:\t%s\t%s" % (insn.address, insn.mnemonic, insn.op_str))

    # "data" instruction generated by SKIPDATA option has no detail
    if insn.id == 0:
        return

    # print instruction prefix
    print_string_hex("\tPrefix:", insn.prefix)

    # print instruction's opcode
    print_string_hex("\tOpcode:", insn.opcode)

    # print instruction format
    print("\tFormat: %s" % insn_format(insn))

    # print operand's REX prefix
    # (non-zero value is relavant for x86_64 instructions)
    print("\trex: 0x%x" % (insn.rex))

    # print operand's address size
    print("\taddr_size: %u" % (insn.addr_size))

    # print modRM byte
    print("\tmodrm: 0x%x" % (insn.modrm))

    # print displacement value
    print("\tdisp: 0x%s" % to_x_32(insn.disp))

    count = insn.op_count(X86_OP_IMM)
    if count > 0:
        print("\timm_count: %u" % count)
        for i in range(count):
            op = insn.op_find(X86_OP_IMM, i + 1)
            print("\t\timms[%u]: 0x%s" % (i + 1, to_x(op.imm)))

    if len(insn.operands) > 0:
        print("\top_count: %u" % len(insn.operands))
        c = -1
        for i in insn.operands:
            c += 1
            if i.type == X86_OP_REG:
                print("\t\toperands[%u].type: REG = %s"
                      % (c, insn.reg_name(i.reg)))
            if i.type == X86_OP_IMM:
                print("\t\toperands[%u].type: IMM = 0x%s" % (c, to_x(i.imm)))
            if i.type == X86_OP_FP:
                print("\t\toperands[%u].type: FP = %f" % (c, i.fp))
            if i.type == X86_OP_MEM:
                print("\t\toperands[%u].type: MEM" % c)
                if i.mem.segment != 0:
                    print("\t\t\toperands[%u].mem.segment: REG = %s" %
                          (c, insn.reg_name(i.mem.segment)))
                if i.mem.base != 0:
                    print("\t\t\toperands[%u].mem.base: REG = %s"
                          % (c, insn.reg_name(i.mem.base)))
                if i.mem.index != 0:
                    print("\t\t\toperands[%u].mem.index: REG = %s" %
                          (c, insn.reg_name(i.mem.index)))
                if i.mem.scale != 1:
                    print("\t\t\toperands[%u].mem.scale: %u" %
                          (c, i.mem.scale))
                if i.mem.disp != 0:
                    print("\t\t\toperands[%u].mem.disp: 0x%s" %
                          (c, to_x(i.mem.disp)))

            print("\t\toperands[%u].size: %u" % (c, i.size))


def insn_format(insn):
    """
    Searches for the mnemonic string corresponding to the opcode of a given
    instruction.

    Args:
        insn: Capstone object representing an instruction.
    Returns:
        String containing the instruction mnemonic (format) if the opcode is
        found. Otherwise, returns not supported.
    """
    for op in OPCODES:
        if op == insn.opcode[0]:
            return OPCODES[op]
    return 'not supported'


def insn_detail(insn):
    """
    Searches for all the parameters in a Capstone object to create an
    Instruction.

    Args:
        insn: Capstone object representing an instruction.
    Returns:
        Instruction object
    """
    def operand_name(op):
        """ Returns the name(string) of a given operand """
        if op.type == X86_OP_REG:
            name = insn.reg_name(op.reg)
        if op.type == X86_OP_IMM:
            name = op.imm
        if op.type == X86_OP_MEM:
            name = insn.reg_name(op.mem.base)
        return name

    def get_offset(op):
        """ Returns the memory offset(string) of a given operand """
        if op.type == X86_OP_MEM:
            return op.mem.disp

    op1 = insn.operands[0]  # Destination reg
    op2 = insn.operands[1]  # Source reg
    label = "%s %s" % (insn.mnemonic, insn.op_str)
    address = insn.address
    mnemonic = insn_format(insn)
    dst = operand_name(op1)
    src = operand_name(op2)
    dst_offset = get_offset(op1)
    src_offset = get_offset(op2)
    return Instruction(label, address, mnemonic,
                       dst, src, dst_offset, src_offset)


def test_class():
    """ Test-run function for debugging """
    insn_list = []
    for (arch, mode, code, comment, syntax) in all_tests:
        print("*" * 16)
        print("Platform: %s" % comment)
        print("Code: %s" % to_hex(code))
        print("Disasm:")

        try:
            md = Cs(arch, mode)
            md.detail = True

            if syntax != 0:
                md.syntax = syntax

            for insn in md.disasm(code, 0x1000):
                print(insn)
                if (insn.mnemonic == "mov"):
                    insn_list.append(insn_detail(insn))
                print_insn_detail(mode, insn)
                print("")
            for insn in insn_list:
                print(insn)
        except CsError as e:
            print("ERROR: %s" % e)


def dump_object(target):
    """ Disassemble an object file in Intel syntax and returns as a String """
    header_size = 7
    objdump = subprocess.check_output(
        ["objdump", "-d", "-M", "intel", target]
    )
    objdump = objdump.decode('utf-8')
    objdump = objdump.split('\n', header_size)[-1]
    return objdump


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='')
    parser.add_argument("target", help="path to target binary")
    args = parser.parse_args()
    target = args.target

    objdump = dump_object(target)
    print("*" * 16)
    print("Dumping: " + target + "\n%s" % objdump)
    opcode = extract_opcode(objdump)
    print("\nOpcode: %s" % opcode)

    X86_CODE32 = bytes.fromhex(opcode)
    all_tests = (
            (CS_ARCH_X86, CS_MODE_32, X86_CODE32, "X86 32 (Intel syntax)", 0),
    )

    test_class()
